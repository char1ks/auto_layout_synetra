#!/usr/bin/env python3
"""
–ì–∏–±—Ä–∏–¥–Ω—ã–π pipeline: LLaVA (–∫–æ–Ω—Ç–µ–∫—Å—Ç) + SearchDet (–æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã) + SAM2 (—Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è)
"""

import os
import sys
import cv2
import numpy as np
import torch
import json
from pathlib import Path
from PIL import Image
import argparse
from datetime import datetime
import time

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ SearchDet
sys.path.append('./searchdet-main')

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–∞—à–∏ –º–æ–¥—É–ª–∏
from llava_sam2_pipeline import MaterialAndDefectAnalyzer, SAM2DefectSegmenter

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º SearchDet
try:
    from mask_withsearch import (
        initialize_models as init_searchdet,
        get_vector,
        adjust_embedding,
        extract_features_from_masks,
        calculate_attention_weights_softmax
    )
    SEARCHDET_AVAILABLE = True
except ImportError as e:
    print(f"‚ö†Ô∏è SearchDet –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
    SEARCHDET_AVAILABLE = False


class HybridDefectDetector:
    """–ì–∏–±—Ä–∏–¥–Ω—ã–π –¥–µ—Ç–µ–∫—Ç–æ—Ä: LLaVA + SearchDet + SAM2"""
    
    def __init__(self, model_type="detailed"):
        print("üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥–∏–±—Ä–∏–¥–Ω–æ–≥–æ –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞...")
        
        # LLaVA –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
        self.llava_analyzer = MaterialAndDefectAnalyzer()
        if model_type != "detailed":
            self.llava_analyzer.switch_model(model_type)
        
        # SAM2 –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–π —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏
        self.sam2_segmenter = SAM2DefectSegmenter()
        
        # SearchDet –¥–ª—è –ø–æ–∏—Å–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        if SEARCHDET_AVAILABLE:
            self.searchdet_resnet, self.searchdet_layer, self.searchdet_transform, self.searchdet_sam = init_searchdet()
            print("‚úÖ SearchDet –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        else:
            print("‚ùå SearchDet –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
    
    def _compare_masks_with_ground_truth(self, all_masks, ground_truth_path, image_shape, results):
        """–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¢–û–õ–¨–ö–û SearchDet –º–∞—Å–æ–∫ —Å ground truth –º–∞—Å–∫–æ–π"""
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º ground truth –º–∞—Å–∫—É
        gt_mask = cv2.imread(ground_truth_path, cv2.IMREAD_GRAYSCALE)
        if gt_mask is None:
            print(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å ground truth –º–∞—Å–∫—É: {ground_truth_path}")
            return {}
        
        # –ü—Ä–∏–≤–æ–¥–∏–º –∫ —Ä–∞–∑–º–µ—Ä—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        h, w = image_shape[:2]
        gt_mask = cv2.resize(gt_mask, (w, h))
        
        # –ë–∏–Ω–∞—Ä–∏–∑–∞—Ü–∏—è: –±–µ–ª—ã–µ –ø–∏–∫—Å–µ–ª–∏ = 1, —á–µ—Ä–Ω—ã–µ = 0
        gt_binary = (gt_mask > 127).astype(np.uint8)
        
        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –¢–û–õ–¨–ö–û SearchDet –º–∞—Å–∫–∏ –≤ –æ–¥–Ω—É —á–µ—Ä–Ω–æ-–±–µ–ª—É—é –º–∞—Å–∫—É
        predicted_combined = np.zeros((h, w), dtype=np.uint8)
        searchdet_masks_count = 0
        
        for i, mask in enumerate(all_masks):
            if i < len(results["annotations"]["defects"]):
                defect_info = results["annotations"]["defects"][i]
                detection_method = defect_info.get("detection_method", "sam2_segmentation")
                category = defect_info.get("category", "defect")
                
                # –ë–µ—Ä–µ–º –¢–û–õ–¨–ö–û SearchDet –º–∞—Å–∫–∏ (—Ç–µ –∂–µ, —á—Ç–æ –≤ –ø–∞–ø–∫–µ masks/)
                if detection_method == "searchdet_missing" or category == "missing_element":
                    if mask.shape[:2] != (h, w):
                        mask = cv2.resize(mask, (w, h))
                    predicted_combined = np.logical_or(predicted_combined, mask > 0).astype(np.uint8)
                    searchdet_masks_count += 1
        
        print(f"   üìä –ò—Å–ø–æ–ª—å–∑—É–µ–º {searchdet_masks_count} SearchDet –º–∞—Å–æ–∫ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è")
        
        # –ú–µ—Ç—Ä–∏–∫–∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
        intersection = np.logical_and(gt_binary, predicted_combined).sum()
        union = np.logical_or(gt_binary, predicted_combined).sum()
        gt_area = gt_binary.sum()
        pred_area = predicted_combined.sum()
        
        # IoU (Intersection over Union)
        iou = intersection / union if union > 0 else 0.0
        
        # Dice Score (F1)
        dice = (2 * intersection) / (gt_area + pred_area) if (gt_area + pred_area) > 0 else 0.0
        
        # Precision (—Ç–æ—á–Ω–æ—Å—Ç—å)
        precision = intersection / pred_area if pred_area > 0 else 0.0
        
        # Recall (–ø–æ–ª–Ω–æ—Ç–∞)
        recall = intersection / gt_area if gt_area > 0 else 0.0
        
        comparison_results = {
            "iou": round(iou * 100, 2),
            "dice_score": round(dice * 100, 2),
            "precision": round(precision * 100, 2),
            "recall": round(recall * 100, 2),
            "ground_truth_area": int(gt_area),
            "predicted_area": int(pred_area),
            "intersection_area": int(intersection),
            "searchdet_masks_used": searchdet_masks_count
        }
        
        print(f"\nüìä –°–†–ê–í–ù–ï–ù–ò–ï –° GROUND TRUTH:")
        print(f"   üéØ IoU (Intersection over Union): {comparison_results['iou']:.2f}%")
        print(f"   üéØ Dice Score (F1): {comparison_results['dice_score']:.2f}%")
        print(f"   üéØ Precision (—Ç–æ—á–Ω–æ—Å—Ç—å): {comparison_results['precision']:.2f}%")
        print(f"   üéØ Recall (–ø–æ–ª–Ω–æ—Ç–∞): {comparison_results['recall']:.2f}%")
        print(f"   üìè Ground Truth –æ–±–ª–∞—Å—Ç—å: {comparison_results['ground_truth_area']} –ø–∏–∫—Å–µ–ª–µ–π")
        print(f"   üìè –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–∞—è –æ–±–ª–∞—Å—Ç—å: {comparison_results['predicted_area']} –ø–∏–∫—Å–µ–ª–µ–π")
        print(f"   üìè –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ: {comparison_results['intersection_area']} –ø–∏–∫—Å–µ–ª–µ–π")
        
        return comparison_results, predicted_combined
        
    def analyze_with_examples(self, image_path, positive_examples_dir, negative_examples_dir, output_dir="./output", ground_truth_path=None):
        """–ü–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø—Ä–∏–º–µ—Ä–æ–≤ –¥–ª—è SearchDet"""
        
        print(f"\nüîç –ì–ò–ë–†–ò–î–ù–´–ô –ê–ù–ê–õ–ò–ó: {image_path}")
        print("=" * 60)
        
        start_time = time.time()
        results = {
            "timestamp": datetime.now().isoformat(),
            "image_path": str(image_path),
            "stages": {}
        }
        
        # –≠–¢–ê–ü 1: LLaVA - –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑
        print("üß† –≠–¢–ê–ü 1: LLaVA –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑...")
        stage1_start = time.time()
        
        material_result = self.llava_analyzer.classify_material(image_path)
        llava_defect_analysis = self.llava_analyzer.analyze_defects(image_path, material_result['material'])
        
        stage1_time = time.time() - stage1_start
        results["stages"]["llava_analysis"] = {
            "duration": stage1_time,
            "material": material_result,
            "defects": llava_defect_analysis
        }
        
        print(f"   ‚úÖ –ú–∞—Ç–µ—Ä–∏–∞–ª: {material_result['material']}")
        print(f"   üîç LLaVA –¥–µ—Ñ–µ–∫—Ç—ã: {llava_defect_analysis.get('defects_found', False)}")
        print(f"   ‚è±Ô∏è –í—Ä–µ–º—è: {stage1_time:.2f} —Å–µ–∫")
        
        # –≠–¢–ê–ü 2: SearchDet - –ø–æ–∏—Å–∫ –∏ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è –¥–µ—Ñ–µ–∫—Ç–æ–≤
        print("\nüîç –≠–¢–ê–ü 2: SearchDet –ø–æ–∏—Å–∫ –∏ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è –¥–µ—Ñ–µ–∫—Ç–æ–≤...")
        stage2_start = time.time()
        
        searchdet_results = None
        if SEARCHDET_AVAILABLE and os.path.exists(positive_examples_dir) and os.path.exists(negative_examples_dir):
            searchdet_results = self._run_searchdet_analysis(
                image_path, positive_examples_dir, negative_examples_dir
            )
        else:
            print("   ‚ö†Ô∏è SearchDet –ø—Ä–æ–ø—É—â–µ–Ω - –Ω–µ—Ç –ø—Ä–∏–º–µ—Ä–æ–≤ –∏–ª–∏ –º–æ–¥—É–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
            searchdet_results = {"found_elements": [], "missing_elements": [], "detected_areas": []}
        
        stage2_time = time.time() - stage2_start
        results["stages"]["searchdet_analysis"] = {
            "duration": stage2_time,
            "result": searchdet_results
        }
        
        print(f"   ‚úÖ –ù–∞–π–¥–µ–Ω–æ –∏ —Å–µ–≥–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–æ –¥–µ—Ñ–µ–∫—Ç–æ–≤: {len(searchdet_results.get('found_elements', []))}")
        print(f"   ‚è±Ô∏è –í—Ä–µ–º—è: {stage2_time:.2f} —Å–µ–∫")
        
        # –≠–¢–ê–ü 3: –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        print("\nüîÑ –≠–¢–ê–ü 3: –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ LLaVA + SearchDet...")
        combined_defects = self._combine_llava_searchdet_results(llava_defect_analysis, searchdet_results)
        
        # –≠–¢–ê–ü 4: SAM2 —Ñ–∏–Ω–∞–ª—å–Ω–∞—è —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è
        print("\nüéØ –≠–¢–ê–ü 4: SAM2 —Ñ–∏–Ω–∞–ª—å–Ω–∞—è —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è...")
        stage4_start = time.time()
        
        sam2_results = self.sam2_segmenter.segment_defects_with_prompts(image_path, combined_defects)
        
        stage4_time = time.time() - stage4_start
        results["stages"]["sam2_segmentation"] = {
            "duration": stage4_time,
            "result": sam2_results
        }
        
        print(f"   ‚úÖ SAM2 –º–∞—Å–∫–∏: {sam2_results.get('num_detections', 0)}")
        print(f"   ‚è±Ô∏è –í—Ä–µ–º—è: {stage4_time:.2f} —Å–µ–∫")
        
        # –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö –∞–Ω–Ω–æ—Ç–∞—Ü–∏–π
        image = cv2.imread(str(image_path))
        annotations = self._create_hybrid_annotations(
            image, sam2_results.get("masks", []), material_result, combined_defects, searchdet_results
        )
        results["annotations"] = annotations
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
        self._save_hybrid_results(image_path, image, sam2_results.get("masks", []), results, output_path)
        
        # –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å ground truth (–µ—Å–ª–∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ)
        if ground_truth_path:
            print(f"\nüîç –≠–¢–ê–ü 5: –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å Ground Truth...")
            comparison_results, predicted_combined = self._compare_masks_with_ground_truth(
                sam2_results.get("masks", []), ground_truth_path, image.shape, results
            )
            results["ground_truth_comparison"] = comparison_results
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—É—é –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—É—é –º–∞—Å–∫—É –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
            image_name = Path(image_path).stem
            predicted_mask_path = output_path / f"{image_name}_predicted_combined_mask.png"
            cv2.imwrite(str(predicted_mask_path), predicted_combined * 255)
            print(f"   üíæ –û–±—ä–µ–¥–∏–Ω–µ–Ω–Ω–∞—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–∞—è –º–∞—Å–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {predicted_mask_path.name}")
        
        total_time = time.time() - start_time
        print(f"\nüéâ –ì–∏–±—Ä–∏–¥–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω –∑–∞ {total_time:.2f} —Å–µ–∫—É–Ω–¥")
        print(f"üìÅ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤: {output_path}")
        
        return results
    
    def _run_searchdet_analysis(self, image_path, positive_dir, negative_dir):
        """–ó–∞–ø—É—Å–∫ SearchDet –¥–ª—è –ø–æ–∏—Å–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤"""
        
        try:
            # –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            example_img = Image.open(image_path).convert("RGB")
            
            # –ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–∏–º–µ—Ä–æ–≤
            positive_imgs = self._load_example_images(positive_dir)
            negative_imgs = self._load_example_images(negative_dir)
            
            if len(positive_imgs) == 0 or len(negative_imgs) == 0:
                print("   ‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∏–º–µ—Ä–æ–≤ –¥–ª—è SearchDet")
                return {"missing_elements": [], "detected_areas": []}
            
            print(f"   üìÅ –ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã: {len(positive_imgs)}")
            print(f"   üìÅ –û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã: {len(negative_imgs)}")
            
            # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
            pos_embeddings = np.stack([
                get_vector(img, self.searchdet_resnet, self.searchdet_layer, self.searchdet_transform).numpy()
                for img in positive_imgs
            ], axis=0).astype(np.float32)
            
            neg_embeddings = np.stack([
                get_vector(img, self.searchdet_resnet, self.searchdet_layer, self.searchdet_transform).numpy()
                for img in negative_imgs
            ], axis=0).astype(np.float32)
            
            # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ query –≤–µ–∫—Ç–æ—Ä–æ–≤
            adjusted_queries = np.stack([
                adjust_embedding(q, pos_embeddings, neg_embeddings)
                for q in pos_embeddings
            ], axis=0).astype(np.float32)
            
            # –ò–ó–ú–ï–ù–ï–ù–û: –ü–æ–∏—Å–∫ –¥–µ—Ñ–µ–∫—Ç–æ–≤ - –±–æ–ª–µ–µ –º—è–≥–∫–∏–π threshold –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω—ã—Ö –¥–µ—Ñ–µ–∫—Ç–æ–≤
            found_elements = self._find_missing_elements(
                example_img, adjusted_queries, similarity_threshold=0.45  # –ú—è–≥—á–µ: >45% —Å—Ö–æ–¥—Å—Ç–≤–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –±–æ–ª—å—à–µ –¥–µ—Ñ–µ–∫—Ç–æ–≤
            )
            
            return {
                "missing_elements": [],  # –ë–æ–ª—å—à–µ –Ω–µ –∏—â–µ–º –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ
                "found_elements": found_elements,  # –ù–∞–π–¥–µ–Ω–Ω—ã–µ –¥–µ—Ç–∞–ª–∏
                "detected_areas": found_elements,  # –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                "positive_examples_count": len(positive_imgs),
                "negative_examples_count": len(negative_imgs)
            }
            
        except Exception as e:
            print(f"   ‚ùå –û—à–∏–±–∫–∞ SearchDet: {e}")
            return {"missing_elements": [], "detected_areas": []}
    
    def _load_example_images(self, directory):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–∏–º–µ—Ä–æ–≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏–∑ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏"""
        images = []
        if not os.path.exists(directory):
            return images
            
        for filename in os.listdir(directory):
            if filename.lower().endswith(('.jpg', '.jpeg', '.png')):
                try:
                    img_path = os.path.join(directory, filename)
                    img = Image.open(img_path).convert("RGB")
                    images.append(img)
                except Exception as e:
                    print(f"   ‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å {filename}: {e}")
                    continue
        
        return images
    
    def _find_missing_elements(self, image, query_vectors, similarity_threshold=0.45):
        """–ü–æ–∏—Å–∫ –¥–µ—Ñ–µ–∫—Ç–æ–≤ —Å –ø–æ–º–æ—â—å—é SearchDet (–Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–∑–∏—Ç–∏–≤–Ω—ã—Ö –ø—Ä–∏–º–µ—Ä–æ–≤ –¥–µ—Ñ–µ–∫—Ç–æ–≤)"""
        
        from segment_anything_hq import SamAutomaticMaskGenerator
        import faiss
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –º–∞—Å–æ–∫ —Å –ø–æ–º–æ—â—å—é SAM - –û–ß–ï–ù–¨ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –¥–µ—Ç–µ–∫—Ü–∏–∏ –º–µ–ª–∫–∏—Ö –¥–µ—Ñ–µ–∫—Ç–æ–≤
        mask_generator = SamAutomaticMaskGenerator(
            model=self.searchdet_sam,
            points_per_side=40,  # –ï—â–µ –±–æ–ª—å—à–µ —Ç–æ—á–µ–∫ –¥–ª—è –ª—É—á—à–µ–≥–æ –ø–æ–∫—Ä—ã—Ç–∏—è –º–µ–ª–∫–∏—Ö –¥–µ—Ñ–µ–∫—Ç–æ–≤
            points_per_batch=80,
            pred_iou_thresh=0.70,  # –ï—â–µ –Ω–∏–∂–µ –¥–ª—è –¥–µ—Ç–µ–∫—Ü–∏–∏ –º–µ–Ω–µ–µ —á–µ—Ç–∫–∏—Ö –¥–µ—Ñ–µ–∫—Ç–æ–≤
            stability_score_thresh=0.75,  # –ï—â–µ –Ω–∏–∂–µ –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –º–∞—Å–æ–∫
            min_mask_region_area=200,  # –°–ò–õ–¨–ù–û —É–º–µ–Ω—å—à–∏–ª–∏ –¥–ª—è –º–µ–ª–∫–∏—Ö –¥–µ—Ñ–µ–∫—Ç–æ–≤ (—Ü–∞—Ä–∞–ø–∏–Ω—ã, —Ç–æ—á–∫–∏)
            box_nms_thresh=0.6,  # –ï—â–µ —Å–ª–∞–±–µ–µ NMS
            crop_nms_thresh=0.6,
        )
        
        masks = mask_generator.generate(np.array(image))
        
        if not masks:
            return []
        
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –º–∞—Å–æ–∫
        image_np = np.array(image)
        mask_vectors = extract_features_from_masks(
            image_np, masks, self.searchdet_resnet, self.searchdet_layer, self.searchdet_transform
        )
        mask_vectors = np.array(mask_vectors, dtype=np.float32)
        
        # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è cosine similarity
        query_vectors = query_vectors / np.linalg.norm(query_vectors, axis=1, keepdims=True)
        mask_vectors = mask_vectors / np.linalg.norm(mask_vectors, axis=1, keepdims=True)
        
        # FAISS –ø–æ–∏—Å–∫
        index = faiss.IndexFlatIP(query_vectors.shape[1])
        index.add(query_vectors)
        
        similarities, indices = index.search(mask_vectors, 1)
        normalized_similarities = (similarities + 1) / 2
        
        # –ò–ó–ú–ï–ù–ï–ù–û: –ü–æ–∏—Å–∫ –æ–±–ª–∞—Å—Ç–µ–π —Å –í–´–°–û–ö–ò–ú —Å—Ö–æ–¥—Å—Ç–≤–æ–º (–ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ –¥–µ—Ç–∞–ª–∏)
        found_indices = np.where(normalized_similarities.flatten() >= similarity_threshold)[0]
        
        found_elements = []
        h, w = image_np.shape[:2]
        total_image_area = h * w
        min_allowed_area = 25  # –£–ú–ï–ù–¨–®–ò–õ–ò –¥–ª—è –º–µ–ª–∫–∏—Ö –¥–µ—Ñ–µ–∫—Ç–æ–≤ (—Ü–∞—Ä–∞–ø–∏–Ω—ã, —Ç–æ—á–∫–∏, —Ç—Ä–µ—â–∏–Ω—ã)
        max_allowed_area_percentage = 1.0  # –£–º–µ–Ω—å—à–∏–ª–∏ –º–∞–∫—Å–∏–º—É–º - –¥–µ—Ñ–µ–∫—Ç—ã –æ–±—ã—á–Ω–æ –Ω–µ –∑–∞–Ω–∏–º–∞—é—Ç –º–Ω–æ–≥–æ –º–µ—Å—Ç–∞
        max_allowed_area = int(total_image_area * max_allowed_area_percentage)
        
        print(f"   üîç –ù–∞–π–¥–µ–Ω–æ {len(found_indices)} –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö –¥–µ—Ç–∞–ª–µ–π –∏–∑ {len(masks)} –º–∞—Å–æ–∫")
        
        for idx in found_indices:
            mask = masks[idx]
            seg = mask['segmentation']
            
            # –í—ã—á–∏—Å–ª–µ–Ω–∏–µ bounding box
            coords = np.column_stack(np.where(seg))
            if len(coords) > 0:
                y_min, x_min = coords.min(axis=0)
                y_max, x_max = coords.max(axis=0)
                
                # –í—ã—á–∏—Å–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–∞—Å–∫–∏
                mask_area = int(seg.sum())
                mask_percentage = (mask_area / total_image_area) * 100
                
                # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∏—Ö –∏ –±–æ–ª—å—à–∏—Ö –º–∞—Å–æ–∫
                if mask_area < min_allowed_area:
                    continue
                if mask_area > max_allowed_area:
                    print(f"   üö´ –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–ª–∏ –±–æ–ª—å—à—É—é –º–∞—Å–∫—É: {mask_area} –ø–∏–∫—Å–µ–ª–µ–π ({mask_percentage:.1f}% –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è)")
                    continue
                
                # –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                bbox_norm = (x_min/w, y_min/h, x_max/w, y_max/h)
                
                found_elements.append({
                    "type": "found_defect",  # –ò–ó–ú–ï–ù–ï–ù–û: —Ç–µ–ø–µ—Ä—å –Ω–∞–π–¥–µ–Ω–Ω—ã–π –¥–µ—Ñ–µ–∫—Ç
                    "bbox": bbox_norm,
                    "area": mask_area,
                    "percentage": mask_percentage,
                    "confidence": float(normalized_similarities[idx][0]),
                    "description": "Defect found and segmented by SearchDet",
                    "mask": seg  # –î–æ–±–∞–≤–ª—è–µ–º —Å–∞–º—É –º–∞—Å–∫—É –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
                })
        
        print(f"   ‚úÖ –ü–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏: {len(found_elements)} –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –¥–µ—Ñ–µ–∫—Ç–æ–≤")
        
        return found_elements
    

    
    def _combine_llava_searchdet_results(self, llava_results, searchdet_results):
        """–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ LLaVA –∏ SearchDet"""
        
        combined = llava_results.copy()
        
        # –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ –æ—Ç SearchDet
        found_elements = searchdet_results.get("found_elements", [])
        if found_elements:
            # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Ç–∏–ø—ã –¥–µ—Ñ–µ–∫—Ç–æ–≤ (—Ç–µ–ø–µ—Ä—å —ç—Ç–æ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –¥–µ—Ç–∞–ª–∏)
            found_types = ["found_detail", "segmented_component"]
            combined["defect_types"] = list(set(combined.get("defect_types", []) + found_types))
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–µ—Ä—å–µ–∑–Ω–æ—Å—Ç—å - –µ—Å–ª–∏ –Ω–∞–π–¥–µ–Ω—ã –¥–µ—Ç–∞–ª–∏, —ç—Ç–æ –Ω–µ –¥–µ—Ñ–µ–∫—Ç
            combined["severity"] = "info"  # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–Ω–æ—Ç—É - –¥–µ—Ç–∞–ª–∏ –Ω–∞–π–¥–µ–Ω—ã –∏ —Å–µ–≥–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã
            combined["completeness"] = "segmented"
            
            # –î–æ–±–∞–≤–ª—è–µ–º bounding boxes –æ—Ç SearchDet
            searchdet_boxes = [elem["bbox"] for elem in found_elements]
            existing_boxes = combined.get("bounding_boxes", [])
            combined["bounding_boxes"] = existing_boxes + searchdet_boxes
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
            combined["description"] += f"\n\nSearchDet found and segmented {len(found_elements)} matching details."
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ SearchDet –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–∞—Ö
            combined["searchdet_found"] = found_elements
            combined["searchdet_missing"] = []  # –ë–æ–ª—å—à–µ –Ω–µ –∏—â–µ–º –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ
        
        return combined
    
    def _create_hybrid_annotations(self, image, masks, material_result, combined_defects, searchdet_results):
        """–°–æ–∑–¥–∞–Ω–∏–µ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–π —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ—Ç –æ–±–µ–∏—Ö —Å–∏—Å—Ç–µ–º"""
        
        annotations = {
            "image_info": {
                "height": image.shape[0],
                "width": image.shape[1],
                "channels": image.shape[2]
            },
            "material": material_result,
            "hybrid_analysis": {
                "llava_defects": combined_defects,
                "searchdet_found": searchdet_results.get("found_elements", []),  # –ò–ó–ú–ï–ù–ï–ù–û
                "searchdet_missing": searchdet_results.get("missing_elements", []),
                "detection_methods": ["llava_coordinates", "searchdet_segmentation", "sam2_segmentation"]  # –ò–ó–ú–ï–ù–ï–ù–û
            },
            "defects": []
        }
        
        # –ê–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –æ—Ç –º–∞—Å–æ–∫ SAM2
        for i, mask in enumerate(masks):
            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            if not contours:
                continue
            
            main_contour = max(contours, key=cv2.contourArea)
            x, y, w, h = cv2.boundingRect(main_contour)
            area = cv2.countNonZero(mask)
            polygon = main_contour.flatten().tolist()
            
            # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –¥–µ—Ç–µ–∫—Ü–∏–∏
            detection_method = "sam2_segmentation"
            defect_type = "defect"
            confidence = 0.85
            
            # –ò–ó–ú–ï–ù–ï–ù–û: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è SearchDet –Ω–∞–π–¥–µ–Ω–Ω—ã–º —ç–ª–µ–º–µ–Ω—Ç–∞–º
            if searchdet_results.get("found_elements"):
                for found in searchdet_results["found_elements"]:
                    bbox = found["bbox"]
                    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è)
                    h_img, w_img = image.shape[:2]
                    search_x1, search_y1, search_x2, search_y2 = [int(c * dim) for c, dim in zip(bbox, [w_img, h_img, w_img, h_img])]
                    
                    if (abs(x - search_x1) < 50 and abs(y - search_y1) < 50):
                        detection_method = "searchdet_found"  # –ò–ó–ú–ï–ù–ï–ù–û
                        defect_type = "found_defect"  # –ò–ó–ú–ï–ù–ï–ù–û
                        confidence = found["confidence"]
                        break
            
            defect_annotation = {
                "id": i + 1,
                "category": defect_type,
                "bbox": [x, y, w, h],
                "area": int(area),
                "segmentation": [polygon],
                "confidence": confidence,
                "detection_method": detection_method,
                "severity": combined_defects.get("severity", "unknown"),
                "completeness": combined_defects.get("completeness", "unknown")
            }
            
            annotations["defects"].append(defect_annotation)
        
        return annotations
    
    def _convert_numpy_to_json(self, obj):
        """–†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è numpy –º–∞—Å—Å–∏–≤–æ–≤ –≤ JSON-—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ —Ç–∏–ø—ã"""
        import numpy as np
        
        if isinstance(obj, np.ndarray):
            return obj.tolist()
        elif isinstance(obj, np.integer):
            return int(obj)
        elif isinstance(obj, np.floating):
            return float(obj)
        elif isinstance(obj, dict):
            return {key: self._convert_numpy_to_json(value) for key, value in obj.items()}
        elif isinstance(obj, list):
            return [self._convert_numpy_to_json(item) for item in obj]
        elif isinstance(obj, tuple):
            return tuple(self._convert_numpy_to_json(item) for item in obj)
        else:
            return obj
    
    def _save_hybrid_results(self, image_path, image, masks, results, output_path):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≥–∏–±—Ä–∏–¥–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è–º–∏"""
        
        image_name = Path(image_path).stem
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è numpy –º–∞—Å—Å–∏–≤–æ–≤ –ø–µ—Ä–µ–¥ —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π
        json_compatible_results = self._convert_numpy_to_json(results)
        
        # JSON —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
        json_path = output_path / f"{image_name}_hybrid_analysis.json"
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(json_compatible_results, f, ensure_ascii=False, indent=2)
        
        print(f"üìÅ –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã: {output_path}")
        
        # 1. –û—Å–Ω–æ–≤–Ω–∞—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
        main_visualization = self._create_hybrid_visualization(image, masks, results)
        cv2.imwrite(str(output_path / f"{image_name}_hybrid_result.jpg"), main_visualization)
        print("   ‚úÖ –û—Å–Ω–æ–≤–Ω–∞—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞")
        
        # 2. –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –º–∞—Å–∫–∞–º–∏ (–±–µ–∑ –ø–∞–Ω–µ–ª–µ–π)
        clean_overlay = self._create_clean_overlay(image, masks, results)
        cv2.imwrite(str(output_path / f"{image_name}_clean_overlay.jpg"), clean_overlay)
        print("   ‚úÖ –ß–∏—Å—Ç–æ–µ –Ω–∞–ª–æ–∂–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ")
        
        # 3. –¢–æ–ª—å–∫–æ –∫–æ–Ω—Ç—É—Ä—ã (–±–µ–∑ –∑–∞–ª–∏–≤–∫–∏)
        contours_only = self._create_contours_visualization(image, masks, results)
        cv2.imwrite(str(output_path / f"{image_name}_contours_only.jpg"), contours_only)
        print("   ‚úÖ –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ç—É—Ä–æ–≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞")
        
        # 4. –û—Ç–¥–µ–ª—å–Ω—ã–µ –º–∞—Å–∫–∏ (—Ç–æ–ª—å–∫–æ SearchDet –º–∞—Å–∫–∏ –≤ –ø–∞–ø–∫–µ masks)
        masks_folder = output_path / "masks"
        masks_folder.mkdir(exist_ok=True)
        
        searchdet_mask_count = 0
        for i, mask in enumerate(masks):
            if i < len(results["annotations"]["defects"]):
                defect_info = results["annotations"]["defects"][i]
                detection_method = defect_info.get("detection_method", "sam2_segmentation")
                category = defect_info.get("category", "defect")
                
                # –ò–ó–ú–ï–ù–ï–ù–û: –°–æ—Ö—Ä–∞–Ω—è–µ–º –¢–û–õ–¨–ö–û SearchDet –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –¥–µ—Ç–∞–ª–∏
                if detection_method == "searchdet_found" or category == "found_detail":
                    searchdet_mask_count += 1
                    
                    # –ë–∏–Ω–∞—Ä–Ω–∞—è –º–∞—Å–∫–∞
                    binary_mask = (mask > 0).astype(np.uint8) * 255
                    mask_path = masks_folder / f"{image_name}_searchdet_mask_{searchdet_mask_count:02d}.png"
                    cv2.imwrite(str(mask_path), binary_mask)
                    
                    # Overlay –º–∞—Å–∫–∞ (—Ü–≤–µ—Ç–Ω–∞—è –Ω–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏)
                    overlay_mask = image.copy()
                    red_color = (0, 0, 255)
                    colored_mask = np.zeros_like(overlay_mask)
                    colored_mask[mask > 0] = red_color
                    alpha = 0.3
                    cv2.addWeighted(overlay_mask, 1-alpha, colored_mask, alpha, 0, overlay_mask)
                    
                    # –ö–æ–Ω—Ç—É—Ä—ã
                    contours, _ = cv2.findContours(binary_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                    if contours:
                        cv2.drawContours(overlay_mask, contours, -1, red_color, 2)
                    
                    overlay_path = masks_folder / f"{image_name}_searchdet_mask_{searchdet_mask_count:02d}_overlay.jpg"
                    cv2.imwrite(str(overlay_path), overlay_mask)
        
        print(f"   ‚úÖ {searchdet_mask_count} SearchDet –º–∞—Å–æ–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ –ø–∞–ø–∫–µ masks/")
        
        # 5. Composite mask (–≤—Å–µ –º–∞—Å–∫–∏ –≤ –æ–¥–Ω–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏)
        if masks:
            composite_mask = self._create_composite_mask(masks, image.shape[:2])
            cv2.imwrite(str(output_path / f"{image_name}_composite_mask.png"), composite_mask)
            print("   ‚úÖ –ö–æ–º–ø–æ–∑–∏—Ç–Ω–∞—è –º–∞—Å–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞")
        
        # 6. Side-by-side —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
        comparison = self._create_before_after_comparison(image, main_visualization)
        cv2.imwrite(str(output_path / f"{image_name}_comparison.jpg"), comparison)
        print("   ‚úÖ –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–æ/–ø–æ—Å–ª–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ")
    
    def _create_clean_overlay(self, image, masks, results):
        """–°–æ–∑–¥–∞–Ω–∏–µ —á–∏—Å—Ç–æ–≥–æ –Ω–∞–ª–æ–∂–µ–Ω–∏—è –¢–û–õ–¨–ö–û –∫—Ä–∞—Å–Ω—ã—Ö –º–∞—Å–æ–∫ SearchDet"""
        
        overlay = image.copy()
        red_color = (0, 0, 255)  # –ö—Ä–∞—Å–Ω—ã–π –¥–ª—è SearchDet
        
        for i, mask in enumerate(masks):
            if i < len(results["annotations"]["defects"]):
                defect_info = results["annotations"]["defects"][i]
                detection_method = defect_info.get("detection_method", "sam2_segmentation")
                category = defect_info.get("category", "defect")
                
                # –ò–ó–ú–ï–ù–ï–ù–û: –ü–û–ö–ê–ó–´–í–ê–ï–ú –¢–û–õ–¨–ö–û SearchDet –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ (–∫—Ä–∞—Å–Ω—ã–µ)
                if detection_method == "searchdet_found" or category == "found_detail":
                    color = red_color
                else:
                    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –º–∞—Å–∫–∏
                    continue
            else:
                # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –º–∞—Å–∫–∏
                continue
            
            # –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è –∫—Ä–∞—Å–Ω–∞—è –º–∞—Å–∫–∞
            colored_mask = np.zeros_like(overlay)
            colored_mask[mask > 0] = color
            
            alpha = 0.3
            cv2.addWeighted(overlay, 1-alpha, colored_mask, alpha, 0, overlay)
            
            # –ö—Ä–∞—Å–Ω—ã–π –∫–æ–Ω—Ç—É—Ä
            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            if contours:
                thickness = 2
                cv2.drawContours(overlay, contours, -1, color, thickness)
        
        # –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ–º 10px —Ä–∞–º–∫—É –æ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–≤–µ—Ä—Ö –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
        border_width = 10
        overlay[:border_width, :] = image[:border_width, :]  # –≤–µ—Ä—Ö–Ω—è—è –ø–æ–ª–æ—Å–∞
        overlay[-border_width:, :] = image[-border_width:, :]  # –Ω–∏–∂–Ω—è—è –ø–æ–ª–æ—Å–∞
        overlay[:, :border_width] = image[:, :border_width]  # –ª–µ–≤–∞—è –ø–æ–ª–æ—Å–∞
        overlay[:, -border_width:] = image[:, -border_width:]  # –ø—Ä–∞–≤–∞—è –ø–æ–ª–æ—Å–∞

        return overlay
    
    def _create_contours_visualization(self, image, masks, results):
        """–°–æ–∑–¥–∞–Ω–∏–µ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –¢–û–õ–¨–ö–û –∫—Ä–∞—Å–Ω—ã—Ö –∫–æ–Ω—Ç—É—Ä–æ–≤ SearchDet"""
        
        contour_image = image.copy()
        red_color = (0, 0, 255)  # –ö—Ä–∞—Å–Ω—ã–π –¥–ª—è SearchDet
        
        searchdet_mask_count = 0  # –°—á–µ—Ç—á–∏–∫ –¥–ª—è –Ω—É–º–µ—Ä–∞—Ü–∏–∏ —Ç–æ–ª—å–∫–æ SearchDet –º–∞—Å–æ–∫
        
        for i, mask in enumerate(masks):
            if i < len(results["annotations"]["defects"]):
                defect_info = results["annotations"]["defects"][i]
                detection_method = defect_info.get("detection_method", "sam2_segmentation")
                category = defect_info.get("category", "defect")
                
                # –ò–ó–ú–ï–ù–ï–ù–û: –ü–û–ö–ê–ó–´–í–ê–ï–ú –¢–û–õ–¨–ö–û SearchDet –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ (–∫—Ä–∞—Å–Ω—ã–µ)
                if detection_method == "searchdet_found" or category == "found_detail":
                    color = red_color
                    searchdet_mask_count += 1
                else:
                    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –º–∞—Å–∫–∏
                    continue
            else:
                # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –º–∞—Å–∫–∏
                continue
            
            # –¢–æ–ª—å–∫–æ –∫—Ä–∞—Å–Ω—ã–µ –∫–æ–Ω—Ç—É—Ä—ã
            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            if contours:
                thickness = 3  # –¢–æ–ª—Å—Ç—ã–µ –∫–æ–Ω—Ç—É—Ä—ã –¥–ª—è SearchDet
                cv2.drawContours(contour_image, contours, -1, color, thickness)
                
                # –ù–æ–º–µ—Ä SearchDet –º–∞—Å–∫–∏ –≤ –∫—Ä–∞—Å–Ω–æ–º –∫—Ä—É–∂–∫–µ
                main_contour = max(contours, key=cv2.contourArea)
                M = cv2.moments(main_contour)
                if M["m00"] != 0:
                    cx = int(M["m10"] / M["m00"])
                    cy = int(M["m01"] / M["m00"])
                    
                    cv2.circle(contour_image, (cx, cy), 20, color, -1)
                    cv2.putText(contour_image, str(searchdet_mask_count), (cx-8, cy+8), 
                               cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)
         
        # –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ–º 10px —Ä–∞–º–∫—É –æ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–≤–µ—Ä—Ö –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
        border_width = 10
        border_mask = np.zeros_like(image, dtype=np.uint8)
        border_mask[:border_width, :] = 255  # –≤–µ—Ä—Ö
        border_mask[-border_width:, :] = 255  # –Ω–∏–∑
        border_mask[:, :border_width] = 255  # –ª–µ–≤–æ
        border_mask[:, -border_width:] = 255  # –ø—Ä–∞–≤–æ
        cv2.copyTo(image, border_mask, contour_image)  # –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª –ø–æ –º–∞—Å–∫–µ

        return contour_image
    
    def _create_composite_mask(self, masks, image_shape):
        """–°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–ø–æ–∑–∏—Ç–Ω–æ–π –º–∞—Å–∫–∏ —Å–æ –≤—Å–µ–º–∏ –¥–µ—Ñ–µ–∫—Ç–∞–º–∏"""
        
        h, w = image_shape
        composite = np.zeros((h, w), dtype=np.uint8)
        
        for i, mask in enumerate(masks):
            # –ö–∞–∂–¥–∞—è –º–∞—Å–∫–∞ –ø–æ–ª—É—á–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ (1, 2, 3, ...)
            composite[mask > 0] = i + 1
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Ü–≤–µ—Ç–Ω—É—é –º–∞—Å–∫—É
        colored_composite = np.zeros((h, w, 3), dtype=np.uint8)
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ä–∞–∑–Ω—ã–µ —Ü–≤–µ—Ç–∞ –¥–ª—è –∫–∞–∂–¥–æ–π –º–∞—Å–∫–∏
        for i in range(len(masks)):
            mask_value = i + 1
            color = [(i * 50) % 255, (i * 80 + 100) % 255, (i * 120 + 150) % 255]
            colored_composite[composite == mask_value] = color
        
        return colored_composite
    
    def _create_before_after_comparison(self, original, processed):
        """–°–æ–∑–¥–∞–Ω–∏–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –¥–æ –∏ –ø–æ—Å–ª–µ"""
        
        # –ò–∑–º–µ–Ω—è–µ–º —Ä–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
        h, w = original.shape[:2]
        
        # –°–æ–∑–¥–∞–µ–º –∫–æ–º–ø–æ–∑–∏—Ü–∏—é side-by-side
        comparison = np.zeros((h, w * 2 + 20, 3), dtype=np.uint8)
        
        # –û—Ä–∏–≥–∏–Ω–∞–ª —Å–ª–µ–≤–∞
        comparison[:h, :w] = original
        
        # –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å–Ω–∞—è –ª–∏–Ω–∏—è
        comparison[:, w:w+20] = (100, 100, 100)
        
        # –û–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–ø—Ä–∞–≤–∞
        processed_resized = cv2.resize(processed, (w, h))
        comparison[:h, w+20:w*2+20] = processed_resized
        
        # –ü–æ–¥–ø–∏—Å–∏
        cv2.putText(comparison, "ORIGINAL", (20, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
        cv2.putText(comparison, "DETECTED DEFECTS", (w + 40, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
        
        return comparison
    
    def _create_hybrid_visualization(self, image, masks, results):
        """–°–æ–∑–¥–∞–Ω–∏–µ —É–ª—É—á—à–µ–Ω–Ω–æ–π –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ —Å –º–∞—Å–∫–∞–º–∏ –ø–æ–≤–µ—Ä—Ö —Ñ–æ—Ç–æ"""
        
        vis_image = image.copy()
        overlay = image.copy()
        
        # –£–ª—É—á—à–µ–Ω–Ω—ã–µ —Ü–≤–µ—Ç–∞ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–µ—Ç–µ–∫—Ü–∏–∏ (–≤ BGR —Ñ–æ—Ä–º–∞—Ç–µ)
        colors = {
            "sam2_segmentation": (0, 255, 128),        # –Ø—Ä–∫–æ-–∑–µ–ª–µ–Ω—ã–π  
            "searchdet_missing": (0, 64, 255),        # –ö—Ä–∞—Å–Ω–æ-–æ—Ä–∞–Ω–∂–µ–≤—ã–π
            "llava_coordinates": (255, 128, 0),       # –ì–æ–ª—É–±–æ–π
            "missing_element": (0, 0, 255),           # –ö—Ä–∞—Å–Ω—ã–π
            "defect": (0, 255, 0),                    # –ó–µ–ª–µ–Ω—ã–π
            "wire_missing": (0, 100, 255),            # –û—Ä–∞–Ω–∂–µ–≤—ã–π
            "scratch": (0, 255, 255),                 # –ñ–µ–ª—Ç—ã–π
            "crack": (128, 0, 255),                   # –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
            "corrosion": (0, 165, 255),               # –û—Ä–∞–Ω–∂–µ–≤—ã–π
        }
        
        print(f"üé® –°–æ–∑–¥–∞–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é –¥–ª—è {len(masks)} –º–∞—Å–æ–∫...")
        
        # –ù–∞–ª–æ–∂–µ–Ω–∏–µ –¢–û–õ–¨–ö–û –ö–†–ê–°–ù–´–• –º–∞—Å–æ–∫ –æ—Ç SearchDet
        for i, mask in enumerate(masks):
            if i < len(results["annotations"]["defects"]):
                defect_info = results["annotations"]["defects"][i]
                detection_method = defect_info.get("detection_method", "sam2_segmentation")
                category = defect_info.get("category", "defect")
                severity = defect_info.get("severity", "unknown")
                
                # –ò–ó–ú–ï–ù–ï–ù–û: –ü–û–ö–ê–ó–´–í–ê–ï–ú –¢–û–õ–¨–ö–û SearchDet –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –¥–µ—Ñ–µ–∫—Ç—ã (–∫—Ä–∞—Å–Ω—ã–µ)
                if detection_method == "searchdet_found" or category == "found_detail":
                    color = (0, 0, 255)  # –ö–†–ê–°–ù–´–ô –¥–ª—è SearchDet –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –¥–µ—Ñ–µ–∫—Ç–æ–≤
                    category = "found_defect"
                else:
                    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –º–∞—Å–∫–∏ (–Ω–µ –æ—Ç SearchDet)
                    continue
                
            else:
                # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –º–∞—Å–∫–∏
                continue
            
            # –°–æ–∑–¥–∞–Ω–∏–µ —Ü–≤–µ—Ç–Ω–æ–π –º–∞—Å–∫–∏ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º –∫ –∫—Ä–∞—è–º
            colored_mask = np.zeros_like(vis_image)
            
            # –û—Å–Ω–æ–≤–Ω–∞—è —Ü–≤–µ—Ç–Ω–∞—è –æ–±–ª–∞—Å—Ç—å
            colored_mask[mask > 0] = color
            
            # –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–æ–µ –Ω–∞–ª–æ–∂–µ–Ω–∏–µ –º–∞—Å–∫–∏
            alpha = 0.4 if severity in ["critical", "severe"] else 0.3
            cv2.addWeighted(overlay, 1-alpha, colored_mask, alpha, 0, overlay)
            
            # –ö–æ–Ω—Ç—É—Ä —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Ç–æ–ª—â–∏–Ω–æ–π –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–µ—Ä—å–µ–∑–Ω–æ—Å—Ç–∏
            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            if contours:
                thickness = 3 if severity in ["critical", "severe"] else 2
                cv2.drawContours(overlay, contours, -1, color, thickness)
                
                # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–º–µ—Ä –∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç–∞ –Ω–∞ –º–∞—Å–∫—É
                main_contour = max(contours, key=cv2.contourArea)
                M = cv2.moments(main_contour)
                if M["m00"] != 0:
                    cx = int(M["m10"] / M["m00"])
                    cy = int(M["m01"] / M["m00"])
                    
                    # –ò–ó–ú–ï–ù–ï–ù–û: –ò–∫–æ–Ω–∫–∞ –¥–ª—è SearchDet –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –¥–µ—Ñ–µ–∫—Ç–æ–≤
                    icon = "‚ö†Ô∏è"
                    
                    # –¢–µ–∫—Å—Ç —Å —Ç–µ–Ω—å—é –¥–ª—è –ª—É—á—à–µ–π —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏  
                    text = f"{icon} DEFECT {i+1}"
                    font = cv2.FONT_HERSHEY_SIMPLEX
                    font_scale = 0.6
                    thickness = 2
                    
                    # –¢–µ–Ω—å
                    cv2.putText(overlay, text, (cx-17, cy+7), font, font_scale, (0, 0, 0), thickness+1)
                    # –û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç
                    cv2.putText(overlay, text, (cx-15, cy+5), font, font_scale, (255, 255, 255), thickness)
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –ø–∞–Ω–µ–ª–∏
        self._add_info_panel(overlay, results, len(masks))
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –ª–µ–≥–µ–Ω–¥—ã
        self._add_legend(overlay, results, colors)
         
         # –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ–º 10px —Ä–∞–º–∫—É –æ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–≤–µ—Ä—Ö –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
        border_width = 10
        border_mask = np.zeros_like(image, dtype=np.uint8)
        border_mask[:border_width, :] = 255  # –≤–µ—Ä—Ö
        border_mask[-border_width:, :] = 255  # –Ω–∏–∑
        border_mask[:, :border_width] = 255  # –ª–µ–≤–æ
        border_mask[:, -border_width:] = 255  # –ø—Ä–∞–≤–æ
        cv2.copyTo(image, border_mask, overlay)  # –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª –ø–æ –º–∞—Å–∫–µ

        return overlay
    
    def _add_info_panel(self, image, results, num_masks):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –ø–∞–Ω–µ–ª–∏"""
        
        llava_result = results["stages"]["llava_analysis"]["material"]
        searchdet_result = results["stages"]["searchdet_analysis"]["result"]
        defects = results["stages"]["llava_analysis"]["defects"]
        
        # –§–æ–Ω –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –ø–∞–Ω–µ–ª–∏
        h, w = image.shape[:2]
        panel_height = 120
        panel = np.zeros((panel_height, w, 3), dtype=np.uint8)
        panel[:] = (40, 40, 40)  # –¢–µ–º–Ω–æ-—Å–µ—Ä—ã–π —Ñ–æ–Ω
        
        # –û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        font = cv2.FONT_HERSHEY_SIMPLEX
        
        # –ò–ó–ú–ï–ù–ï–ù–û: –ó–∞–≥–æ–ª–æ–≤–æ–∫ –¥–ª—è –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –¥–µ—Ñ–µ–∫—Ç–æ–≤
        title = "üîç SEARCHDET FOUND DEFECTS (RED MASKS ONLY)"
        cv2.putText(panel, title, (10, 25), font, 0.7, (255, 255, 255), 2)
        
        # –ú–∞—Ç–µ—Ä–∏–∞–ª
        material_text = f"üì¶ Material: {llava_result['material'].upper()} (conf: {llava_result['confidence']:.2f})"
        cv2.putText(panel, material_text, (10, 50), font, 0.5, (100, 255, 100), 1)
        
        # –ò–ó–ú–ï–ù–ï–ù–û: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ SearchDet –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –¥–µ—Ñ–µ–∫—Ç—ã
        found_count = len(searchdet_result.get('found_elements', []))
        red_masks_text = f"üî¥ RED MASKS (SearchDet): {found_count} defects found and segmented"
        cv2.putText(panel, red_masks_text, (10, 70), font, 0.5, (0, 100, 255), 1)
        
        # –ò–ó–ú–ï–ù–ï–ù–û: –°—Ç–∞—Ç—É—Å —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –¥–µ—Ñ–µ–∫—Ç–æ–≤
        status_text = "‚ö†Ô∏è DEFECTS DETECTED" if found_count > 0 else "‚úÖ NO DEFECTS FOUND"
        status_color = (0, 100, 255) if found_count > 0 else (0, 255, 0)  # –ö—Ä–∞—Å–Ω—ã–π –¥–ª—è –¥–µ—Ñ–µ–∫—Ç–æ–≤, –∑–µ–ª–µ–Ω—ã–π –¥–ª—è –∏—Ö –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è
        cv2.putText(panel, status_text, (w-300, 50), font, 0.5, status_color, 1)
        
        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –ø–∞–Ω–µ–ª—å —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
        combined = np.vstack([panel, image])
        image[:] = combined[:h]  # –†–∞–∑–º–µ—â–∞–µ–º –ø–∞–Ω–µ–ª—å —Å–≤–µ—Ä—Ö—É, –æ–±—Ä–µ–∑–∞—è –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    
    def _add_legend(self, image, results, colors):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ª–µ–≥–µ–Ω–¥—ã —Ç–æ–ª—å–∫–æ –¥–ª—è SearchDet (–∫—Ä–∞—Å–Ω—ã–µ –º–∞—Å–∫–∏)"""
        
        h, w = image.shape[:2]
        
        # –ò–ó–ú–ï–ù–ï–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ SearchDet
        searchdet_result = results["stages"]["searchdet_analysis"]["result"]
        found_count = len(searchdet_result.get('found_elements', []))
        
        if found_count > 0:
            # –ü—Ä–æ—Å—Ç–∞—è –ª–µ–≥–µ–Ω–¥–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è SearchDet
            legend_width = 250
            legend_height = 60
            legend_x = w - legend_width - 10
            legend_y = h - legend_height - 10
            
            # –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω
            overlay = image.copy()
            cv2.rectangle(overlay, (legend_x, legend_y), (legend_x + legend_width, legend_y + legend_height), 
                         (0, 0, 0), -1)
            cv2.addWeighted(image, 0.7, overlay, 0.3, 0, image)
            
            # –ó–∞–≥–æ–ª–æ–≤–æ–∫
            cv2.putText(image, "üé® LEGEND:", (legend_x + 10, legend_y + 20), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 255, 255), 1)
            
            # –ö—Ä–∞—Å–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç –¥–ª—è SearchDet
            cv2.rectangle(image, (legend_x + 10, legend_y + 35), (legend_x + 25, legend_y + 50), (0, 0, 255), -1)
            cv2.rectangle(image, (legend_x + 10, legend_y + 35), (legend_x + 25, legend_y + 50), (255, 255, 255), 1)
            
            # –ò–ó–ú–ï–ù–ï–ù–û: –¢–µ–∫—Å—Ç –¥–ª—è –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –¥–µ—Ñ–µ–∫—Ç–æ–≤
            cv2.putText(image, "Found Defects (SearchDet)", (legend_x + 35, legend_y + 47), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.35, (255, 255, 255), 1)


def main():
    parser = argparse.ArgumentParser(description="–ì–∏–±—Ä–∏–¥–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –¥–µ—Ñ–µ–∫—Ç–æ–≤: LLaVA + SearchDet + SAM2")
    parser.add_argument("--image", required=True, help="–ü—É—Ç—å –∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞")
    parser.add_argument("--positive", required=True, help="–ü–∞–ø–∫–∞ —Å –ø—Ä–∏–º–µ—Ä–∞–º–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤")
    parser.add_argument("--negative", required=True, help="–ü–∞–ø–∫–∞ —Å –ø—Ä–∏–º–µ—Ä–∞–º–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö/–æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤")
    parser.add_argument("--output", default="./output", help="–î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤")
    parser.add_argument("--model", default="detailed", 
                       choices=["detailed", "standard", "latest", "onevision"],
                       help="–¢–∏–ø –º–æ–¥–µ–ª–∏ LLaVA")
    parser.add_argument("--ground-truth", default=None, 
                       help="–ü—É—Ç—å –∫ ground truth –º–∞—Å–∫–µ (—á–µ—Ä–Ω–æ-–±–µ–ª–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ) –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è")
    
    args = parser.parse_args()
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∞–π–ª–æ–≤ –∏ –ø–∞–ø–æ–∫
    if not Path(args.image).exists():
        print(f"‚ùå –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ: {args.image}")
        return
    
    if not Path(args.positive).exists():
        print(f"‚ùå –ü–∞–ø–∫–∞ —Å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º–∏ –ø—Ä–∏–º–µ—Ä–∞–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {args.positive}")
        return
        
    if not Path(args.negative).exists():
        print(f"‚ùå –ü–∞–ø–∫–∞ —Å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º–∏ –ø—Ä–∏–º–µ—Ä–∞–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {args.negative}")
        return
    
    if args.ground_truth and not Path(args.ground_truth).exists():
        print(f"‚ùå Ground truth –º–∞—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {args.ground_truth}")
        return
    
    # –°–æ–∑–¥–∞–Ω–∏–µ –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞
    detector = HybridDefectDetector(model_type=args.model)
    
    # –ó–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞
    results = detector.analyze_with_examples(
        args.image, args.positive, args.negative, args.output, args.ground_truth
    )
    
    if results:
        print(f"\nüìä –ò–¢–û–ì–û–í–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê:")
        print(f"   üß™ –ú–∞—Ç–µ—Ä–∏–∞–ª: {results['stages']['llava_analysis']['material']['material']}")
        print(f"   üîç LLaVA –¥–µ—Ñ–µ–∫—Ç—ã: {results['stages']['llava_analysis']['defects'].get('defects_found', False)}")
        print(f"   üéØ SearchDet –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –¥–µ—Ñ–µ–∫—Ç—ã: {len(results['stages']['searchdet_analysis']['result'].get('found_elements', []))}")
        
        # –ò–ó–ú–ï–ù–ï–ù–û: –ü–æ–¥—Å—á–∏—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ SearchDet –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –¥–µ—Ñ–µ–∫—Ç—ã –≤ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
        searchdet_masks_shown = 0
        for defect in results['annotations']['defects']:
            if (defect.get('detection_method') == 'searchdet_found' or 
                defect.get('category') == 'found_detail'):
                searchdet_masks_shown += 1
        
        print(f"   üî¥ –ö–†–ê–°–ù–´–• –º–∞—Å–æ–∫ –ø–æ–∫–∞–∑–∞–Ω–æ: {searchdet_masks_shown} (—Ç–æ–ª—å–∫–æ SearchDet –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –¥–µ—Ñ–µ–∫—Ç—ã)")
        print(f"   üìù –í—Å–µ–≥–æ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–π: {len(results['annotations']['defects'])}")
        total_time = sum(stage['duration'] for stage in results['stages'].values())
        print(f"   ‚è±Ô∏è –û–±—â–µ–µ –≤—Ä–µ–º—è: {total_time:.2f} —Å–µ–∫")
        print(f"\nüî¥ –í –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç—Å—è –¢–û–õ–¨–ö–û –ö–†–ê–°–ù–´–ï –º–∞—Å–∫–∏ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –¥–µ—Ñ–µ–∫—Ç–æ–≤ –æ—Ç SearchDet!")
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å ground truth
        if 'ground_truth_comparison' in results:
            gt_comp = results['ground_truth_comparison']
            print(f"\nüìä GROUND TRUTH –ú–ï–¢–†–ò–ö–ò:")
            print(f"   üéØ IoU: {gt_comp['iou']:.1f}%")
            print(f"   üéØ Dice Score: {gt_comp['dice_score']:.1f}%")
            print(f"   üéØ Precision: {gt_comp['precision']:.1f}%")
            print(f"   üéØ Recall: {gt_comp['recall']:.1f}%")


if __name__ == "__main__":
    main() 